n <- 1000
z <- rbinom(n,1,0.5)
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 1, 1)
y <- z* x1 + (1-z)*x2
pList <- seq(0,3,0.01)
liVec <- numeric(length(pList))
for (i in c(1:length(pList))){
v <- pList[i]
textFun <- function(y){
exp(-y^2/2) + 1/sqrt(v)*exp(-(y-0)^2/(2*v))
}
textFunVec <- Vectorize(textFun)
liVec[i] <- sum(log(textFunVec(pList)))
}
plot(textFunVec(pList) ~ pList, type="l", lty = 1, xlab="", ylab="")
textFun(0.3)
?glmnet
library(glmnet)
?glmnet
According to Friedman, Hastie & Tibshirani (2010) 'strategy is to select a minimum value lambda_min = epsilon * lambda_max, and construct a sequence of K values of lambda decreasing from lambda_max to lambda_min on the log scale. Typical values are epsilon = 0.001 and K = 100.'
## Load library and generate some data to illustrate:
library("glmnet")
set.seed(1)
n <- 100
x <- matrix(rnorm(n*20), n, 20)
y <- rnorm(n)
## Standardize variables: (need to use n instead of (n-1) as denominator)
mysd <- function(z) sqrt(sum((z-mean(z))^2)/length(z))
sx <- scale(x, scale = apply(x, 2, mysd))
sx <- as.matrix(sx, ncol = 20, nrow = 100)
## Calculate lambda path (first get lambda_max):
lambda_max <- max(abs(colSums(sx*y)))/n
epsilon <- .0001
K <- 100
lambdapath <- round(exp(seq(log(lambda_max), log(lambda_max*epsilon),
length.out = K)), digits = 10)
lambdapath
## Compare with glmnet's lambda path:
fitGLM <- glmnet(sx, y)
fitGLM$lambda
seq(log(lambda_max), log(lambda_max*epsilon),
length.out = K)
lambdapath
lambda_max
?cv.glmnet
library(glmnet)
?cv.glmnet
# upper bound of difference is 1.4
# when epsilon = 0.35, the scale of the noise is 1.4/0.35, the ratio is exp(1.4/0.35)
1.4/0.35
print(1.4/2.4)
print(1.4/2.8)
print(1.4/5.6)
print(exp(2.8))
print(exp(5.6))
log(cosh(10))
a <- 4
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.1
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.2
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.8
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.5
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.2
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.3
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.6
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.5
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.3
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 0.3
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
a <- 1
resid <- seq(-10,10, 0.1)
loss <- 1/a*log(cosh(a*resid))
plot(loss~resid)
##################################################################
# Lasso or elastic net in high dimensional setting
##################################################################
# set directory to the source file folder
# in R
#setwd(getSrcDirectory()[1])
# # in Rstudio
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(MASS)
library(caret)
library(glmnet)
library(expm)
datGen <- function(n, Xdist, sigMat, be1, be2, be3, alpha){
# number of predictors from user 1
p1 <- length(be1)
# number of predictors from user 2
p2 <- length(be2)
# number of shared predictors
p3 <- length(be3)
# total number of predictors
p <- p1 + p2 + p3
# generate predictors data
if (Xdist == "normal"){
Xdat_tmp <- matrix(rnorm((n*p)), nrow = n, ncol = p)
}else if (Xdist == "uniform"){
Xdat_tmp <- matrix(runif((n*p)), nrow = n, ncol = p)
}
Xdat <- Xdat_tmp %*% sqrtm(sigMat)
x1 <- Xdat[,c(1 : p1)]
x2 <- Xdat[,c((p1+1) : (p1 + p2))]
if (p3 != 0){
x3 <- Xdat[,c((p1 + p2 + 1) : p)]
}
# generate response data (coefficients are all 1)
if (p3 != 0){
eta <-  as.numeric(x1 %*% be1 + x2%*% be2 + x3%*%be3)
}else{
eta <-  as.numeric(x1 %*% be1 + x2%*% be2)
}
y <- rnorm(n, mean = eta, sd = 1)
if (p3 != 0){
# full data set
dat <- data.frame(y = y, x1 = x1, x2 = x2, x3 = x3)
# data for user 1
dat1 <- data.frame(y = y, x1 = x1, x3 = x3)
# data for user 2
dat2 <- data.frame(y = y, x2 = x2, x3 = x3)
}else{
# full data set
dat <- data.frame(y = y, x1 = x1, x2 = x2)
# data for user 1
dat1 <- data.frame(y = y, x1 = x1)
# data for user 2
dat2 <- data.frame(y = y, x2 = x2)
}
return(list(dat = dat, dat1 = dat1, dat2 = dat2))
}
AssistedTraining <- function(lamTest, nit, Xmat1, Xmat2, y, Xmat1_pred, Xmat2_pred, y_pred, p1,p2,p3){
# matrix to store beta values
betaMat <- matrix(nrow=(nit + 1), ncol = (1 + p1 + p2 + p3))
MSEvec <- numeric((nit + 1))
# initialize
mod1 <- glmnet(Xmat1, y, family = "gaussian", lambda =  lamTest , alpha = 0)
betaMat[1,] <- c((mod1$a0 + 0), mod1$beta[1:p1], rep(0,p2), (mod1$beta[-c(1:p1)] ))
predV <- mod1$a0 +  Xmat1_pred %*%  mod1$beta
MSEvec[1] <- mean((y_pred - predV)^2)
for (i in c(1:nit)){
# update eta
eta1 <- as.numeric(mod1$a0 +  Xmat1 %*%  mod1$beta)
# update beta2
mod2 <- glmnet(Xmat2, y, offset = eta1, family = "gaussian", lambda =  lamTest , alpha = 0)
# update eta
eta2 <- as.numeric(mod2$a0 +  Xmat2 %*%  mod2$beta)
# update beta1
mod1 <- glmnet(Xmat1, y, offset = eta2, family = "gaussian", lambda =  lamTest , alpha = 0)
# combined coefficients
betaMat[i,] <- c((mod1$a0 + mod2$a0), mod1$beta[1:p1], mod2$beta[1:p2], (mod1$beta[-c(1:p1)] + mod2$beta[-c(1:p2)]))
# predicted values
predV <- as.numeric((mod1$a0 + mod2$a0) +  Xmat1_pred %*%  mod1$beta + Xmat2_pred %*%  mod2$beta)
# mean squared error
MSEvec[(i + 1)] <- mean((y_pred - predV)^2)
}
result <- list(beta=betaMat, MSE=MSEvec)
}
TestFun <- function(nrep, n, Xdist, nPred, sig, nit, nK, be1, be2, be3, alpha){
MSEmat <- matrix(nrow = nrep, ncol = (nit + 1))
MSEmat_oracle <- numeric(nrep)
lambdaAssVec <- numeric(nrep)
lambdaOraVec <- numeric(nrep)
# take the "be" values as the means instead of the coefficient values
be1_mean <- be1
be2_mean <- be2
be3_mean <- be3
# lengths of betas
p1 <- length(be1_mean)
p2 <- length(be2_mean)
p3 <- length(be3_mean)
p <- p1 + p2 + p3
for (j in c(1:nrep)){
message(j)
# randomly generate coefficients
be1 <- mvrnorm(mu = be1_mean, Sigma = diag(rep(1, length(be1_mean))))
be2 <- mvrnorm(mu = be2_mean, Sigma = diag(rep(1, length(be2_mean))))
if (p3 != 0){
be3 <- mvrnorm(mu = be3_mean, Sigma = diag(rep(1, length(be3_mean))))
}
# covariance matrix of the predictors
ar1_cor <- function(n, rho) {
exponent <- abs(matrix(1:n - 1, nrow = n, ncol = n, byrow = TRUE) -
(1:n - 1))
rho^exponent
}
sigMat <- ar1_cor(p, sig)
#=============== Generate data set for training ==============
datList <- datGen(n = n, Xdist = Xdist, sigMat = sigMat, be1 = be1, be2 = be2, be3 = be3, alpha = alpha)
dat <- datList$dat
# predictor observations
Xmat <- as.matrix(dat[,-1])
# data for user 1
dat1 <- datList$dat1
# predictor observations
Xmat1 <- as.matrix(dat1[,-1])
# data for user 2
dat2 <- datList$dat2
# predictor observations
Xmat2 <- as.matrix(dat2[,-1])
#=============== Generate new data set for prediction ==============
datList_Pred <- datGen(n = nPred, Xdist = Xdist, sigMat = sigMat, be1 = be1, be2 = be2, be3 = be3)
dat_Pred <- datList_Pred$dat
# predictor observations
Xmat_Pred <- as.matrix(dat_Pred[,-1])
# data for user 1
dat1_Pred <- datList_Pred$dat1
# predictor observations
Xmat1_Pred <- as.matrix(dat1_Pred[,-1])
# data for user 2
dat2_Pred <- datList_Pred$dat2
# predictor observations
Xmat2_Pred <- as.matrix(dat2_Pred[,-1])
# Obtain a list of lambdas from Xmat1
CVA <- cv.glmnet(Xmat1, dat$y, nfolds = nK, family = "gaussian", alpha = 0)
lambdaList <- CVA$lambda
# split the dataset
CVInd <- createMultiFolds(c(1:n), k = nK, times = 1)
# Vector to store MSE for each lambda value
MSEvec <- numeric(length(lambdaList))
for (lamIndex in seq_along(lambdaList)){
lamTest <- lambdaList[lamIndex]
# collect MSE
MSE_tmp <- numeric(nK)
for (k in c(1:nK)){
# fit the model
test <- AssistedTraining(lamTest=lamTest, nit=nit, Xmat1=Xmat1[CVInd[[k]],], Xmat2= Xmat2[CVInd[[k]],], y=dat$y[CVInd[[k]]], Xmat1_pred=Xmat1[-CVInd[[k]],], Xmat2_pred=Xmat2[-CVInd[[k]],], y_pred=dat$y[-CVInd[[k]]], p1=p1,p2=p2,p3=p3)
# calculate the MSE
MSE_tmp[k] <- test$MSE[length(test$MSE)]
}
MSEvec[lamIndex] <- mean(MSE_tmp)
}
# select the lambda with the smallest MSE from CV
minInd <- which(MSEvec == min(MSEvec))
lambdaAssisted <- lambdaList[minInd]
#================ train the assisted learning model=================
mod_assisted <- AssistedTraining(lamTest=lambdaAssisted, nit=nit, Xmat1=Xmat1, Xmat2= Xmat2, y=dat$y, Xmat1_pred=Xmat1_Pred, Xmat2_pred=Xmat2_Pred, y_pred=dat_Pred$y, p1=p1, p2=p2, p3=p3)
#================ calculate beta from the oracle model=================
require(glmnet)
lambMin <- cv.glmnet(Xmat, dat$y, nfolds = nK, family = "gaussian", alpha = 0)$lambda.min
mod <- glmnet(Xmat, dat$y, family = "gaussian", lambda = lambMin, alpha = 0)
coeff <- c(mod$a0, as.numeric(mod$beta))
oracle_MSE <- mean((dat_Pred$y - (mod$a0 + Xmat_Pred %*% mod$beta))^2)
MSEmat[j,] <- mod_assisted$MSE
MSEmat_oracle[j] <- oracle_MSE
lambdaAssVec[j] <- lambdaAssisted
lambdaOraVec[j] <- lambMin
}
result <- list(MSE=MSEmat, MSE_oracle=MSEmat_oracle,
lambdaAssVec=lambdaAssVec, lambdaOraVec=lambdaOraVec)
return(result)
}
# size of the prediction data
nPred <- 10^6
# number of training rounds
nit <- 5
# number of CV folds in selecting lambda
nK <- 10
# number of replications
nrep <- 100
#nrep <- 100
# distribution of predictors
Xdist = "uniform"
set.seed(20)
n <- 300
sig <- 0.1
alpha <- 1
for (betasetting in c(1,2)){
if (betasetting == 1){
# be1 <-  c(0.3, 0.2, 0.1, rep(0,197))
# be2 <-  c(0.3, 0.2, 0.1, rep(0,197))
# be3 <-  c(0.3, 0.2, 0.1, rep(0,197))
be1 <-  c(0.3, 0.2, 0.1)
be2 <-  c(0.3, 0.2, 0.1)
be3 <-  c(0.3, 0.2, 0.1)
}else if (betasetting == 2){
be1 <-  c(0.3, 0.2, 0.1, rep(0,197))
be2 <-  c(0.3, 0.2, 0.1, rep(0,197))
be3 <-  c()
}
TrainingRes <- TestFun(nrep=nrep,
n=n,
Xdist=Xdist,
nPred=nPred,
sig=sig,
nit=nit,
nK=nK,
be1=be1,
be2=be2,
be3=be3,
alpha = alpha)
filename <- paste("_betasetting_", betasetting, "n_", n, "_", "sig_", sig, "_Xdist_",  Xdist, "_alpha_", alpha,  sep="")
write.csv(TrainingRes$MSE, paste("data/EnetTrainingAssistedMSE_", filename, ".csv", sep=""))
write.csv(TrainingRes$MSE_oracle, paste("data/EnetTrainingOracleMSE_", filename, ".csv", sep=""))
write.csv(TrainingRes$lambdaAssVec, paste("data/EnetTrainingAssistedLam_", filename, ".csv", sep=""))
write.csv(TrainingRes$lambdaOraVec, paste("data/EnetTrainingOracleLam_", filename, ".csv", sep=""))
}
t <- 4
2 * ((1 + t)^6 - (1-t)^6)/t^6
t <- 100
2 * ((1 + t)^6 - (1-t)^6)/t^6
t <- 64
2 * ((1 + t)^6 - (1-t)^6)/t^6
t <- 64
2 * ((1 + t)^6 - (t-1)^6)/t^6
t*3
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
t <- 8
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
t <- 4
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
t <- 8
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
t <- 10
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
t <- 8
1/4 * 2 * ((t + 1)^6 - (t-1)^6)/t^6  * t*3/(t-1)^3
1/8
setwd("~/Documents/Study_19fall/RA/GLM_privacy/codes/AssistedLearning_codes/kddcup99-mld")
data <- read.csv("processed.csv", header = TRUE)
head(data)
data2 <- data
data2[which(data$label == 'normal' | 'Dos')]
summary(data2)
data2[which(data$label == 'normal')]
data2[which(data$label == 'normal'), ]
data2[which(data$label == 'normal' or 'Dos'), ]
data2[which(data$label == 'normal' | 'Dos'), ]
data2[which(data$label %in% c('normal', 'Dos')), ]
summary(data2)
data3$label <- as.factor(data3$label)
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$label <- as.factor(data3$label)
data3$count <- as.factor(data3$count)
names(data3)
summary(data3)
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$label <- as.factor(data3$label)
data3$flag <- as.factor(data3$flag)
summary(data3)
data3$service <- as.factor(data3$service)
data3$protocol_type <- as.factor(data3$protocol_type)
summary(data3)
?glm
mod1 <- glm(flag~., data=data3, family=binomial)
data3$num_outbound_cmds <- NULL
set.seed(20)
sample(c(1:nrow(data3), 10000, replace=TRUE))
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE))]
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
mod1 <- glm(flag~., data=data4, family=binomial)
summary(mod1)
data3$flag <- data3$flag == 'normal'
data3$num_outbound_cmds <- NULL
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
mod1 <- glm(flag~., data=data4, family=binomial)
summary(mod1)
data5 <- data4[,"count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate"]
data4[,"count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate"]
data5 <- data4["count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate"]
data4[,"count"]
data5 <- data4[, c("count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(flag~., data=data4, family=binomial)
summary(mod1)
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data5 <- data4[, c("count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
data3$flag <- data3$flag == 'normal'
data3$num_outbound_cmds <- NULL
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
data5 <- data4[, c("count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
data5 <- data4[, c("flag", "count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data5 <- data4[, c("flag", "count","srv_count")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data5 <- data4[, c("flag", "serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data5 <- data4[, c("flag", "srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data5 <- data4[, c("flag", "srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
data4 <- data3[sample(c(1:nrow(data3), 5000, replace=TRUE)), ]
data5 <- data4[, c("flag", "srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
cor(data5$flag, data5$srv_diff_host_rate)
data5$flag
data3$flag <- as.numeric(data3$flag == 'normal')
data3$flag
sum(data3$flag)
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$label
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$protocol_type <- as.factor(data3$protocol_type)
data3$service <- as.factor(data3$service)
data3$flag <- as.numeric(data3$flag == 'normal')
data3$num_outbound_cmds <- NULL
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
data5 <- data4[, c("flag", "srv_diff_host_rate")]
mod1 <- glm(flag~., data=data5, family=binomial)
summary(mod1)
cor(data5$flag, data5$srv_diff_host_rate)
data5$flag
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$flag
data3$label
data3$label == 'normal'
as.numeric(data3$flag == 'normal')
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
# data3$label <- as.factor(data3$label)
data3$protocol_type <- as.factor(data3$protocol_type)
data3$service <- as.factor(data3$service)
data3$flag <- as.numeric(data3$label == 'normal')
data3$num_outbound_cmds <- NULL
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
data5 <- data4[, c("label", "count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(label~., data=data5, family=binomial)
cor(data5$label, data5$srv_diff_host_rate)
as.numeric(data3$flag == 'normal')
data5$label
data3 <- data2[which(data$label %in% c('normal', 'Dos')), ]
data3$protocol_type <- as.factor(data3$protocol_type)
data3$service <- as.factor(data3$service)
data3$label <- as.numeric(data3$label == 'normal')
data3$num_outbound_cmds <- NULL
set.seed(20)
data4 <- data3[sample(c(1:nrow(data3), 10000, replace=TRUE)), ]
data5 <- data4[, c("label", "count","srv_count","serror_rate",
"srv_serror_rate","rerror_rate","srv_rerror_rate","same_srv_rate",
"diff_srv_rate","srv_diff_host_rate")]
mod1 <- glm(label~., data=data5, family=binomial)
summary(mod1)
cor(data5$label, data5$srv_diff_host_rate)
data5 <- data4[, c("dst_host_count","dst_host_srv_count",
"dst_host_same_srv_rate","dst_host_diff_srv_rate","dst_host_same_src_port_rate",
"dst_host_srv_diff_host_rate","dst_host_serror_rate","dst_host_srv_serror_rate",
"dst_host_rerror_rate","dst_host_srv_rerror_rate")]
mod1 <- glm(label~., data=data5, family=binomial)
data5 <- data4[, c("label", dst_host_count","dst_host_srv_count",
data5 <- data4[, c("label", "dst_host_count","dst_host_srv_count",
"dst_host_same_srv_rate","dst_host_diff_srv_rate","dst_host_same_src_port_rate",
"dst_host_srv_diff_host_rate","dst_host_serror_rate","dst_host_srv_serror_rate",
"dst_host_rerror_rate","dst_host_srv_rerror_rate")]
mod1 <- glm(label~., data=data5, family=binomial)
summary(mod1)
data5$label
mod1 <- glm(label~., data=data5, family=binomial)
summary(mod1)
cor(data5)
cor(data5)[1,]
